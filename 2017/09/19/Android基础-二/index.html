<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/favicon.ico"/>
	<link rel="shortcut icon" href="/img/favicon.ico">
	
			    <title>
    CREEPERDCH's Tech
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="creeper creeperdc creeperdch CREEPERDCH" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Patient</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">HOME</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">CATEGORIES</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/android/">android</a></li><li><a class="category-link" href="/categories/hexo/">hexo</a></li><li><a class="category-link" href="/categories/java/">java</a></li><li><a class="category-link" href="/categories/markdown/">markdown</a></li><li><a class="category-link" href="/categories/novel/">novel</a></li><li><a class="category-link" href="/categories/字帖/">字帖</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="ABOUT">
		                ABOUT
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tags/" title="TAG">
		                TAG
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/CREEPERDCH" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="Instagram" href="https://www.instagram.com/creeperdch/" target="_blank" rel="noopener">
                            <i class="icon fa fa-Instagram"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://ws2.sinaimg.cn/large/006tKfTcgy1ft8gblyzdkj31kw0xm17p.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >Android基础(二)</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h3 id="1-静态内部类-内部类-匿名内部类分别是什么-为什么内部类会持有外部类的引用-持有的引用是this还是其他"><a href="#1-静态内部类-内部类-匿名内部类分别是什么-为什么内部类会持有外部类的引用-持有的引用是this还是其他" class="headerlink" title="1.静态内部类,内部类,匿名内部类分别是什么?为什么内部类会持有外部类的引用?持有的引用是this还是其他?"></a><strong>1.静态内部类,内部类,匿名内部类分别是什么?为什么内部类会持有外部类的引用?持有的引用是this还是其他?</strong></h3><p>​    <strong>静态内部类：</strong>使用static修饰的内部类</p>
<p>​    <strong>内部类：</strong>就是在某个类的内部又定义了一个类，内部类所嵌入的类称为外部类</p>
<p>​    <strong>匿名内部类：</strong>使用new生成的内部类</p>
<pre><code> 内部类的产生依赖于外部类，持有的引用是类名.this
</code></pre><h3 id="2-Java中try-catch-finally的执行顺序"><a href="#2-Java中try-catch-finally的执行顺序" class="headerlink" title="2.Java中try catch finally的执行顺序?"></a><strong>2.Java中try catch finally的执行顺序?</strong></h3><p>​    先执行try中代码，如果发生异常执行catch中代码，最后一定会执行finally中代码</p>
<h3 id="3-equals与-的区别"><a href="#3-equals与-的区别" class="headerlink" title="3.equals与==的区别?"></a><strong>3.equals与==的区别?</strong></h3><p>​    ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是         不是相等</p>
<h3 id="4-Java的四种引用的区别"><a href="#4-Java的四种引用的区别" class="headerlink" title="4.Java的四种引用的区别"></a><strong>4.Java的四种引用的区别</strong></h3><p>​    <strong>强引用：</strong>如果一个对象具有强引用，它就不会被垃圾回收器(GC)回收。即使当前内存空间不足，JVM 也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象</p>
<p>​    <strong>软引用：</strong>在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收</p>
<p>​    <strong>弱引用：</strong>具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象</p>
<p>​    <strong>虚引用：</strong>顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收</p>
<h1 id="Thread-AsyncTask相关面试题"><a href="#Thread-AsyncTask相关面试题" class="headerlink" title="Thread/AsyncTask相关面试题:"></a><strong>Thread/AsyncTask相关面试题:</strong></h1><h3 id="1-wait-和sleep-的区别"><a href="#1-wait-和sleep-的区别" class="headerlink" title="1.wait()和sleep()的区别"></a><strong>1.wait()和sleep()的区别</strong></h3><p>​    sleep()来自Thread类,wait()来自Object类</p>
<p>​    调用sleep()方法的过程中,线程不会释放对象锁;而调用wait()方法,线程会释放对象锁</p>
<p>​    sleep睡眠后不出让系统资源,wait让出系统资源,其他线程可以占用CPU</p>
<p>​    sleep(milliseconds)需要传入一个睡眠时间的参数，时间一到会自动唤醒</p>
<h3 id="2-介绍下-AsyncTask的内部实现以及适用的场景"><a href="#2-介绍下-AsyncTask的内部实现以及适用的场景" class="headerlink" title="2.介绍下 AsyncTask的内部实现以及适用的场景"></a><strong>2.介绍下 AsyncTask的内部实现以及适用的场景</strong></h3><p>​    AsyncTask 内部也是 Handler 机制来完成的，只不过 Android 提供了执行框架来提供线程池来执行相应地任务，因为线程池的大小问题，所以 AsyncTask 只应该用来执行耗时时间较短的任务，比如 HTTP 请求，大规模的下载和数据库的更改不适用于 AsyncTask，因为会导致线程池堵塞，没有线程来执行其他的任务，导致的情形是会发生 AsyncTask 根本执行不了的问题。</p>
<h1 id="网络相关面试题"><a href="#网络相关面试题" class="headerlink" title="网络相关面试题:"></a><strong>网络相关面试题:</strong></h1><h3 id="1-为什么说TCP是可靠的而UDP是不可靠的-为什么UDP比TCP快"><a href="#1-为什么说TCP是可靠的而UDP是不可靠的-为什么UDP比TCP快" class="headerlink" title="1.为什么说TCP是可靠的而UDP是不可靠的?为什么UDP比TCP快?"></a><strong>1.为什么说TCP是可靠的而UDP是不可靠的?为什么UDP比TCP快?</strong></h3><p>​    TCP/IP协议高，因为其拥有三次握手双向机制，这一机制保证校验了数据，保证了他的可靠性。</p>
<p>​    UDP就没有了，UDP信息发出后,不验证是否到达对方,所以不可靠。</p>
<p>​    但是就速度来说，还是UDP协议更高，毕竟其无需重复返回验证，只是一次性的</p>
<h3 id="2-简述对Http与Https协议的了解"><a href="#2-简述对Http与Https协议的了解" class="headerlink" title="2.简述对Http与Https协议的了解"></a><strong>2.简述对Http与Https协议的了解</strong></h3><p>​    Http(超文本传输协议)是一个基于请求与响应模式的、无状态的、应用层的协议,Http请求由三部分组成，分别是：请求行、消息报头、请求正文,其中消息报头包括普通报头、请求报头、响应报头、实体报头</p>
<p>​    HTTPS(全称：Hyper Text Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL</p>
<h3 id="3-Http请求中GET和POST方法的区别"><a href="#3-Http请求中GET和POST方法的区别" class="headerlink" title="3.Http请求中GET和POST方法的区别"></a><strong>3.Http请求中GET和POST方法的区别</strong></h3><p>​    <strong>GET:</strong>从指定的服务器中获取数据，明文发送内容</p>
<p>​    <strong>POST :</strong>提交数据给指定的服务器处理</p>
<p>​    <strong>区别:</strong>    POST请求不能被缓存下来</p>
<p>​            POST请求不会保存在浏览器浏览记录中</p>
<pre><code>         以POST请求的URL无法保存为浏览器书签
</code></pre><p>​            POST请求没有长度限制</p>
<h1 id="Fragment相关面试题"><a href="#Fragment相关面试题" class="headerlink" title="Fragment相关面试题:"></a><strong>Fragment相关面试题:</strong></h1><h3 id="1-Fragment-如何实现类似-Activity-栈的压栈和出栈效果的"><a href="#1-Fragment-如何实现类似-Activity-栈的压栈和出栈效果的" class="headerlink" title="1.Fragment 如何实现类似 Activity 栈的压栈和出栈效果的"></a><strong>1.Fragment 如何实现类似 Activity 栈的压栈和出栈效果的</strong></h3><p>​    Fragment 的事物管理器内部维持了一个双向链表结构,该结构可以记录我们每次add的</p>
<p>Fragment 和 replace 的 Fragment，然后当我们点击 back 按钮的时候会自动帮我们实现退栈操作</p>
<h3 id="2-Fragment-的好处"><a href="#2-Fragment-的好处" class="headerlink" title="2.Fragment 的好处"></a><strong>2.Fragment 的好处</strong></h3><p>​    Fragment 可以使你能够将 activity 分离成多个可重用的组件，每个都有它自己的生命周期和</p>
<p>UI</p>
<p>​    Fragment 可以轻松得创建动态灵活的 UI 设计，可以适应于不同的屏幕尺寸。从手机到平板电</p>
<p>脑</p>
<p>​    Fragment 是一个独立的模块,紧紧地与 activity 绑定在一起。可以运行中动态地移除、加入、</p>
<p>交换等</p>
<p>​    Fragment 提供一个新的方式让你在不同的安卓设备上统一你的 UI</p>
<p>​    Fragment 解决 Activity 间的切换不流畅，轻量切换</p>
<p>​    Fragment 替代 Tab Activity 做导航，性能更好(Tab Activity 已经过时了)</p>
<p>​    Fragment 在 4.2.版本中新增嵌套 fragment 使用方法，能够生成更好的界面效果</p>
<h3 id="3-如何切换-Fragment-不重新实例化"><a href="#3-如何切换-Fragment-不重新实例化" class="headerlink" title="3.如何切换 Fragment,不重新实例化"></a><strong>3.如何切换 Fragment,不重新实例化</strong></h3><p>​    <strong>正确的切换方式是:</strong></p>
<p>​    add()，</p>
<p>​    切换时 hide()，add()另一个 Fragment;</p>
<p>​    再次切换时，只需 hide()当前，show()另一个</p>
<h1 id="View相关面试题"><a href="#View相关面试题" class="headerlink" title="View相关面试题:"></a><strong>View相关面试题:</strong></h1><h3 id="1-onInterceptTouchEvent-和onTouchEvent-的区别"><a href="#1-onInterceptTouchEvent-和onTouchEvent-的区别" class="headerlink" title="1.onInterceptTouchEvent()和onTouchEvent()的区别"></a><strong>1.onInterceptTouchEvent()和onTouchEvent()的区别</strong></h3><p>​    onInterceptTouchEvent() 用于拦截触摸事件</p>
<p>​    onTouchEvent()             用于处理触摸事件</p>
<h3 id="2-SurfaceView和View的区别"><a href="#2-SurfaceView和View的区别" class="headerlink" title="2.SurfaceView和View的区别"></a><strong>2.SurfaceView和View的区别</strong></h3><p>​    SurfaceView中采用了双缓存技术，在单独的线程中更新界面</p>
<p>​    View在UI线程中更新界面</p>
<h3 id="3-View的绘制过程"><a href="#3-View的绘制过程" class="headerlink" title="3.View的绘制过程"></a><strong>3.View的绘制过程</strong></h3><p>​    一个View要显示在界面上，需要经历一个View树的遍历过程，这个过程又可以分为三个过程，也就是自定义View中的三要素：大小，位置，画什么，即onMesure()，onLayout(),onDraw()</p>
<p>​    onMesure()确定一个View的大小;</p>
<p>​    onLayout()确定View在父节点上的位置;</p>
<p>​    onDraw()绘制View 的内容;</p>
<h1 id="性能优化相关面试题"><a href="#性能优化相关面试题" class="headerlink" title="性能优化相关面试题:"></a><strong>性能优化相关面试题:</strong></h1><h3 id="1-ListView卡顿的原因与性能优化"><a href="#1-ListView卡顿的原因与性能优化" class="headerlink" title="1.ListView卡顿的原因与性能优化"></a><strong>1.ListView卡顿的原因与性能优化</strong></h3><p>​    <strong>重用convertView：</strong>通过复用convertview来减少不必要的view的创建，另外Inflate操作会把xml文件实例化成相应的View实例，属于IO操作，是耗时操作</p>
<p>​    <strong>减少findViewById()操作:</strong>将xml文件中的元素封装成viewholder静态类，通过convertview的setTag和getTag方法将view与相应的holder对象绑定在一起，避免不必要的findviewbyid操作</p>
<p>​    <strong>避免在 getView 方法中做耗时的操作</strong></p>
<p>​    <strong>使用 RecycleView 代替listview</strong></p>
<p>​    <strong>ListView 中元素避免半透明</strong></p>
<h3 id="2-三级缓存的原理"><a href="#2-三级缓存的原理" class="headerlink" title="2.三级缓存的原理"></a><strong>2.三级缓存的原理</strong></h3><p>​    从缓存中加载。</p>
<p>​    从本地文件中加载(数据库，SDcard)</p>
<p>​    从网络加载</p>
<h1 id="其他面试题"><a href="#其他面试题" class="headerlink" title="其他面试题:"></a><strong>其他面试题:</strong></h1><h3 id="1-android中进程的优先级"><a href="#1-android中进程的优先级" class="headerlink" title="1.android中进程的优先级"></a><strong>1.android中进程的优先级</strong></h3><p>​    前台进程</p>
<p>​    可见进程</p>
<p>​    服务进程</p>
<p>​    后台进程</p>
<p>​    空进程</p>
<h3 id="2-apk安装卸载的原理"><a href="#2-apk安装卸载的原理" class="headerlink" title="2.apk安装卸载的原理"></a><strong>2.apk安装卸载的原理</strong></h3><p>​    <strong>安装过程：</strong>复制apk安装包到data/app目录下，解压并扫描安装包，把dex文件(dalvik字节码)保存到dalvik-cache目录，并data/data目录下创建对应的应用数据目录</p>
<p>​    <strong>卸载过程：</strong>删除安装过程中在上述三个目录下创建的文件及目录</p>
<p><strong>3.Android 中如何捕获未捕获的异常</strong></p>
<p>​    自定义一个Application 实 现UncaughExceptionHandler,覆写 UncaughtExceptionHandler 的 onCreate 和 uncaughtException 方法</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 valine -->
<div id="comment">
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#comment' ,
        notify: false,
        verify: false,
        app_id: 'H78Pg6j0lgmXRgYJayNMsIe3-gzGzoHsz',
        app_key: 'YwHuAUtNNefaFp7HySR7VvuW',
        placeholder: 'ヾﾉ≧∀≦)o来快活啊!',
        pageSize: '10',
        avatar: '',
        avatar_cdn: 'https://gravatar.loli.net/avatar/'
    });
</script>
</div>
<style>
   #comment{
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
